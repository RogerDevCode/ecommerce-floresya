/**
 * ðŸŒ¸ FloresYa - Category Controller Tests
 * Tests para categoryController con Vitest y Supabase
 * 
 * @swagger
 * components:
 *   schemas:
 *     CategoryTest:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           description: ID Ãºnico de la categorÃ­a
 *         name:
 *           type: string
 *           description: Nombre de la categorÃ­a
 *         description:
 *           type: string
 *           description: DescripciÃ³n de la categorÃ­a
 *         image_url:
 *           type: string
 *           description: URL de la imagen de la categorÃ­a
 *         active:
 *           type: boolean
 *           description: Estado activo de la categorÃ­a
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import request from 'supertest';
import express from 'express';

// Mock Supabase client
const mockSupabaseClient = {
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    limit: vi.fn().mockReturnThis(),
    order: vi.fn().mockReturnThis(),
    insert: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    delete: vi.fn().mockReturnThis(),
    single: vi.fn(() => Promise.resolve({ data: null, error: null })),
    ilike: vi.fn().mockReturnThis(),
    then: vi.fn(() => Promise.resolve({ data: [], error: null, count: 0 }))
};

// Mock database service
const mockDatabaseService = {
    getClient: () => mockSupabaseClient,
    count: vi.fn().mockResolvedValue(0),
    insert: vi.fn().mockResolvedValue([{ id: 1 }]),
    update: vi.fn().mockResolvedValue([{ id: 1 }]),
    delete: vi.fn().mockResolvedValue(true)
};

vi.mock('../../backend/src/services/databaseService.js', () => ({
    databaseService: mockDatabaseService
}));

// Mock logger
vi.mock('../../backend/src/utils/bked_logger.js', () => ({
    log: vi.fn(),
    logger: {
        info: vi.fn(),
        error: vi.fn(),
        warn: vi.fn()
    },
    startTimer: vi.fn(() => ({
        end: vi.fn()
    }))
}));

// Mock queryBuilder con API completa
const mockPrismaLikeAPI = {
    category: {
        findMany: vi.fn(),
        findFirst: vi.fn(),
        findUnique: vi.fn(),
        create: vi.fn(),
        update: vi.fn(),
        delete: vi.fn()
    }
};

vi.mock('../../backend/src/services/queryBuilder.js', () => ({
    createPrismaLikeAPI: vi.fn(() => mockPrismaLikeAPI)
}));

// Import controllers after mocks
const { getAllCategories, getCategoryById, createCategory, updateCategory, deleteCategory } = await import('../../backend/src/controllers/categoryController.js');

// Setup Express app
const app = express();
app.use(express.json());
app.get('/categories', getAllCategories);
app.get('/categories/:id', getCategoryById);
app.post('/categories', createCategory);
app.put('/categories/:id', updateCategory);
app.delete('/categories/:id', deleteCategory);

describe('Category Controller - Supabase Tests', () => {
    const testCategory = {
        id: 1,
        name: 'Test Category',
        description: 'Category for testing',
        image_url: 'https://example.com/test.jpg',
        active: true,
        created_at: new Date(),
        updated_at: new Date()
    };

    beforeEach(() => {
        vi.clearAllMocks();
        // Reset mocks to default values
        mockPrismaLikeAPI.category.findMany.mockResolvedValue([]);
        mockPrismaLikeAPI.category.findFirst.mockResolvedValue(null);
        mockPrismaLikeAPI.category.create.mockResolvedValue(testCategory);
        mockPrismaLikeAPI.category.update.mockResolvedValue(testCategory);
        mockPrismaLikeAPI.category.delete.mockResolvedValue(testCategory);
        mockDatabaseService.count.mockResolvedValue(0);
    });

    describe('GET /categories', () => {
        it('should return all active categories', async () => {
            mockPrismaLikeAPI.category.findMany.mockResolvedValue([testCategory]);

            const response = await request(app)
                .get('/categories')
                .expect(200);

            expect(response.body).toHaveProperty('success', true);
            expect(response.body).toHaveProperty('data');
            expect(Array.isArray(response.body.data)).toBe(true);
            expect(response.body.data).toHaveLength(1);
            expect(response.body.data[0].name).toBe(testCategory.name);
            
            expect(mockPrismaLikeAPI.category.findMany).toHaveBeenCalledWith({
                where: { active: true },
                include: {},
                orderBy: { name: 'asc' }
            });
        });

        it('should filter categories by active status', async () => {
            mockPrismaLikeAPI.category.findMany.mockResolvedValue([]);

            const response = await request(app)
                .get('/categories?active=false')
                .expect(200);

            expect(mockPrismaLikeAPI.category.findMany).toHaveBeenCalledWith({
                where: { active: false },
                include: {},
                orderBy: { name: 'asc' }
            });
        });

        it('should include products when requested', async () => {
            const categoryWithProducts = {
                ...testCategory,
                products: [
                    { id: 1, name: 'Test Product', price: '25.99' }
                ]
            };
            mockPrismaLikeAPI.category.findMany.mockResolvedValue([categoryWithProducts]);

            const response = await request(app)
                .get('/categories?includeProducts=true')
                .expect(200);

            expect(mockPrismaLikeAPI.category.findMany).toHaveBeenCalledWith({
                where: { active: true },
                include: {
                    products: {
                        select: ['id', 'name', 'price', 'featured', 'active']
                    }
                },
                orderBy: { name: 'asc' }
            });
        });

        it('should handle database errors gracefully', async () => {
            mockPrismaLikeAPI.category.findMany.mockRejectedValue(new Error('Database connection failed'));

            const response = await request(app)
                .get('/categories')
                .expect(500);

            expect(response.body).toHaveProperty('success', false);
            expect(response.body).toHaveProperty('message', 'Error fetching categories');
        });
    });

    describe('GET /categories/:id', () => {
        it('should return a category by ID', async () => {
            mockPrismaLikeAPI.category.findFirst.mockResolvedValue(testCategory);

            const response = await request(app)
                .get('/categories/1')
                .expect(200);

            expect(response.body).toHaveProperty('success', true);
            expect(response.body).toHaveProperty('data');
            expect(response.body.data.id).toBe(testCategory.id);
            expect(response.body.data.name).toBe(testCategory.name);
            
            expect(mockPrismaLikeAPI.category.findFirst).toHaveBeenCalledWith({
                where: { id: 1 },
                include: {}
            });
        });

        it('should return 404 for non-existent category', async () => {
            mockPrismaLikeAPI.category.findFirst.mockResolvedValue(null);

            const response = await request(app)
                .get('/categories/999')
                .expect(404);

            expect(response.body).toHaveProperty('success', false);
            expect(response.body).toHaveProperty('message', 'Category not found');
        });
    });

    describe('POST /categories', () => {
        it('should create a new category with valid data', async () => {
            const newCategory = {
                ...testCategory,
                id: 2,
                name: 'New Test Category'
            };
            mockPrismaLikeAPI.category.create.mockResolvedValue(newCategory);

            const categoryData = {
                name: 'New Test Category',
                description: 'A new category for testing',
                image_url: 'https://example.com/new.jpg',
                active: true
            };

            const response = await request(app)
                .post('/categories')
                .send(categoryData)
                .expect(201);

            expect(response.body).toHaveProperty('success', true);
            expect(response.body).toHaveProperty('data');
            expect(response.body.data.name).toBe('New Test Category');
            
            expect(mockPrismaLikeAPI.category.create).toHaveBeenCalledWith({
                data: {
                    name: categoryData.name,
                    description: categoryData.description,
                    image_url: categoryData.image_url,
                    active: Boolean(categoryData.active)
                }
            });
        });

        it('should return error for missing required fields', async () => {
            const invalidData = {
                description: 'Missing name'
            };

            const response = await request(app)
                .post('/categories')
                .send(invalidData)
                .expect(400);

            expect(response.body).toHaveProperty('success', false);
            expect(response.body).toHaveProperty('message', 'Category name is required');
            expect(mockPrismaLikeAPI.category.create).not.toHaveBeenCalled();
        });
    });

    describe('PUT /categories/:id', () => {
        it('should update an existing category', async () => {
            const updatedCategory = { 
                ...testCategory, 
                name: 'Updated Category', 
                description: 'Updated description' 
            };
            
            // Mock first call to find existing category
            mockPrismaLikeAPI.category.findFirst.mockResolvedValueOnce(testCategory);
            // Mock name conflict check - return empty array (no conflicts)
            mockPrismaLikeAPI.category.findMany.mockResolvedValue([]);
            // Mock update operation via databaseService
            mockDatabaseService.update.mockResolvedValue([updatedCategory]);

            const updateData = {
                name: 'Updated Category',
                description: 'Updated description'
            };

            const response = await request(app)
                .put('/categories/1')
                .send(updateData)
                .expect(200);

            expect(response.body).toHaveProperty('success', true);
            expect(response.body).toHaveProperty('data');
            expect(response.body.data.name).toBe('Updated Category');
            expect(response.body.data.description).toBe('Updated description');
        });

        it('should return 404 for non-existent category', async () => {
            mockPrismaLikeAPI.category.findFirst.mockResolvedValue(null);

            const updateData = { name: 'Updated Name' };

            const response = await request(app)
                .put('/categories/999')
                .send(updateData)
                .expect(404);

            expect(response.body).toHaveProperty('success', false);
            expect(response.body).toHaveProperty('message', 'Category not found');
            expect(mockPrismaLikeAPI.category.update).not.toHaveBeenCalled();
        });
    });

    describe('DELETE /categories/:id', () => {
        it('should delete an existing category without products', async () => {
            mockPrismaLikeAPI.category.findFirst.mockResolvedValue(testCategory);
            mockDatabaseService.count.mockResolvedValue(0); // No products
            mockDatabaseService.delete.mockResolvedValue(true);

            const response = await request(app)
                .delete('/categories/1')
                .expect(200);

            expect(response.body).toHaveProperty('success', true);
            expect(response.body).toHaveProperty('message', 'Category deleted successfully');
            
            expect(mockPrismaLikeAPI.category.findFirst).toHaveBeenCalledWith({
                where: { id: 1 }
            });
            expect(mockDatabaseService.count).toHaveBeenCalledWith('products', { category_id: 1 });
            expect(mockDatabaseService.delete).toHaveBeenCalledWith('categories', { id: 1 });
        });

        it('should not delete category with products', async () => {
            mockPrismaLikeAPI.category.findFirst.mockResolvedValue(testCategory);
            mockDatabaseService.count.mockResolvedValue(2); // Has 2 products

            const response = await request(app)
                .delete('/categories/1')
                .expect(409); // Conflict status code as per controller

            expect(response.body).toHaveProperty('success', false);
            expect(response.body.message).toContain('Cannot delete category with 2 associated products');
            expect(mockDatabaseService.delete).not.toHaveBeenCalled();
        });

        it('should return 404 for non-existent category', async () => {
            mockPrismaLikeAPI.category.findFirst.mockResolvedValue(null);

            const response = await request(app)
                .delete('/categories/999')
                .expect(404);

            expect(response.body).toHaveProperty('success', false);
            expect(response.body).toHaveProperty('message', 'Category not found');
            expect(mockPrismaLikeAPI.category.delete).not.toHaveBeenCalled();
        });
    });
});